---
layout: post
title:  "数据结构与算法问题集合"
date:   2025-08-07 11:24:00 +0800
tags:
  - 后端
---

## 关于数组和链表的几个必知必会的代码实现

### 数组
1. 实现一个支持动态扩容的数组
```go
// 支持范型的动态数组（Go 1.18+）
type DynamicArray[T any] struct {
    data     []T
    capacity int
    size     int
}

func NewDynamicArray[T any](initCap int) *DynamicArray[T] {
    return &DynamicArray[T]{
        data:     make([]T, initCap),
        capacity: initCap,
        size:     0,
    }
}

func (a *DynamicArray[T]) Append(val T) {
    if a.size == a.capacity {
        newData := make([]T, a.capacity*2)
        copy(newData, a.data)
        a.data = newData
        a.capacity *= 2
    }
    a.data[a.size] = val
    a.size++
}

func (a *DynamicArray[T]) Get(idx int) T {
    if idx < 0 || idx >= a.size {
        panic("index out of range")
    }
    return a.data[idx]
}

func (a *DynamicArray[T]) Len() int {
    return a.size
}
```
2. 实现一个大小固定的有序数组，支持动态增删改操作
```go
// 固定大小有序数组，支持动态增删改（Go 1.18+）
type SortedArray[T any] struct {
    data     []T
    size     int
    capacity int
    less     func(a, b T) bool // 比较函数
}

func NewSortedArray[T any](cap int, less func(a, b T) bool) *SortedArray[T] {
    return &SortedArray[T]{
        data:     make([]T, cap),
        size:     0,
        capacity: cap,
        less:     less,
    }
}

// 插入元素，自动保持有序
func (a *SortedArray[T]) Insert(val T) bool {
    if a.size == a.capacity {
        return false // 超出容量
    }
    idx := 0
    for idx < a.size && a.less(a.data[idx], val) {
        idx++
    }
    // 插入并后移
    copy(a.data[idx+1:], a.data[idx:a.size])
    a.data[idx] = val
    a.size++
    return true
}

// 删除指定下标元素
func (a *SortedArray[T]) Delete(idx int) bool {
    if idx < 0 || idx >= a.size {
        return false
    }
    copy(a.data[idx:], a.data[idx+1:a.size])
    a.size--
    return true
}

// 修改指定下标元素并保持有序
func (a *SortedArray[T]) Update(idx int, val T) bool {
    if idx < 0 || idx >= a.size {
        return false
    }
    // 删除原元素
    old := a.data[idx]
    a.Delete(idx)
    // 插入新元素
    return a.Insert(val)
}

// 获取指定下标元素
func (a *SortedArray[T]) Get(idx int) T {
    if idx < 0 || idx >= a.size {
        panic("index out of range")
    }
    return a.data[idx]
}

func (a *SortedArray[T]) Len() int {
    return a.size
}
```

3. 实现两个有序数组合并为一个有序数组
```go
// 合并两个有序数组为一个有序数组（Go 1.18+）
func MergeSortedArrays[T any](a, b []T, less func(a, b T) bool) []T {
    i, j := 0, 0
    res := make([]T, 0, len(a)+len(b))
    for i < len(a) && j < len(b) {
        if less(a[i], b[j]) {
            res = append(res, a[i])
            i++
        } else {
            res = append(res, b[j])
            j++
        }
    }
    for i < len(a) {
        res = append(res, a[i])
        i++
    }
    for j < len(b) {
        res = append(res, b[j])
        j++
    }
    return res
}
```

### 链表
1. 实现单链表，支持增删操作
```go
type SinglyNode[T any] struct {
    Val  T
    Next *SinglyNode[T]
}

type SinglyList[T any] struct {
    Head *SinglyNode[T]
}

func (l *SinglyList[T]) Insert(val T) {
    node := &SinglyNode[T]{Val: val}
    node.Next = l.Head
    l.Head = node
}

func (l *SinglyList[T]) Delete(val T, equal func(a, b T) bool) bool {
    var prev *SinglyNode[T]
    cur := l.Head
    for cur != nil {
        if equal(cur.Val, val) {
            if prev == nil {
                l.Head = cur.Next
            } else {
                prev.Next = cur.Next
            }
            return true
        }
        prev = cur
        cur = cur.Next
    }
    return false
}
```

2. 实现循环链表，支持增删操作
```go
type CircularNode[T any] struct {
    Val  T
    Next *CircularNode[T]
}

type CircularList[T any] struct {
    Head *CircularNode[T]
}

func (l *CircularList[T]) Insert(val T) {
    node := &CircularNode[T]{Val: val}
    if l.Head == nil {
        node.Next = node
        l.Head = node
        return
    }
    cur := l.Head
    for cur.Next != l.Head {
        cur = cur.Next
    }
    cur.Next = node
    node.Next = l.Head
}

func (l *CircularList[T]) Delete(val T, equal func(a, b T) bool) bool {
    if l.Head == nil {
        return false
    }
    cur := l.Head
    var prev *CircularNode[T]
    for {
        if equal(cur.Val, val) {
            if prev == nil {
                // 删除头结点
                tail := l.Head
                for tail.Next != l.Head {
                    tail = tail.Next
                }
                if tail == l.Head {
                    l.Head = nil
                } else {
                    tail.Next = cur.Next
                    l.Head = cur.Next
                }
            } else {
                prev.Next = cur.Next
            }
            return true
        }
        prev = cur
        cur = cur.Next
        if cur == l.Head {
            break
        }
    }
    return false
}
```

3. 实现双向链表，支持增删操作
```go
type DoublyNode[T any] struct {
    Val  T
    Prev *DoublyNode[T]
    Next *DoublyNode[T]
}

type DoublyList[T any] struct {
    Head *DoublyNode[T]
    Tail *DoublyNode[T]
}

func (l *DoublyList[T]) InsertHead(val T) {
    node := &DoublyNode[T]{Val: val}
    node.Next = l.Head
    if l.Head != nil {
        l.Head.Prev = node
    }
    l.Head = node
    if l.Tail == nil {
        l.Tail = node
    }
}

func (l *DoublyList[T]) InsertTail(val T) {
    node := &DoublyNode[T]{Val: val}
    node.Prev = l.Tail
    if l.Tail != nil {
        l.Tail.Next = node
    }
    l.Tail = node
    if l.Head == nil {
        l.Head = node
    }
}

func (l *DoublyList[T]) Delete(val T, equal func(a, b T) bool) bool {
    cur := l.Head
    for cur != nil {
        if equal(cur.Val, val) {
            if cur.Prev != nil {
                cur.Prev.Next = cur.Next
            } else {
                l.Head = cur.Next
            }
            if cur.Next != nil {
                cur.Next.Prev = cur.Prev
            } else {
                l.Tail = cur.Prev
            }
            return true
        }
        cur = cur.Next
    }
    return false
}
```

4. 实现单链表反转
```go
type SinglyNode[T any] struct {
    Val  T
    Next *SinglyNode[T]
}

type SinglyList[T any] struct {
    Head *SinglyNode[T]
}

func (l *SinglyList[T]) Reverse() {
    var prev *SinglyNode[T]
    cur := l.Head
    for cur != nil {
        next := cur.Next
        cur.Next = prev
        prev = cur
        cur = next
    }
    l.Head = prev
}
```

5. 实现两个有序的链表合并为一个有序链表
```go
func MergeSortedLists[T any](l1, l2 *SinglyList[T], less func(a, b T) bool) *SinglyList[T] {
    dummy := &SinglyNode[T]{}
    cur := dummy
    p1, p2 := l1.Head, l2.Head
    for p1 != nil && p2 != nil {
        if less(p1.Val, p2.Val) {
            cur.Next = p1
            p1 = p1.Next
        } else {
            cur.Next = p2
            p2 = p2.Next
        }
        cur = cur.Next
    }
    if p1 != nil {
        cur.Next = p1
    }
    if p2 != nil {
        cur.Next = p2
    }
    return &SinglyList[T]{Head: dummy.Next}
}
```
6. 求单链表的中间结点（快慢指针法）
```go
func (l *SinglyList[T]) MiddleNode() *SinglyNode[T] {
    slow, fast := l.Head, l.Head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    return slow
}
```
7. Three Sum(求三数之和)
```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    res := [][]int{}
    n := len(nums)
    for i := 0; i < n-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue // 跳过重复
        }
        left, right := i+1, n-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                // 跳过重复
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return res
}
```
8. Majority Element(求众数)
```
func majorityElement(nums []int) int {
    res := make(map[int]int)
    for _, val := range nums {
        res[val]++
    }
    max, ret := 0, 0
    for k, v := range res {
        if v > max {
            ret = k
            max = v
        }
    }
    return ret
}
```
9. 判断链表中是否有环。
```go
func hasCycle[T any](head *SinglyNode[T]) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```
10. 给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。
```go
import (
    "container/heap"
)

// 堆节点结构
type heapNode[T any] struct {
    node *SinglyNode[T]
}

type nodeHeap[T any] struct {
    arr  []*heapNode[T]
    less func(a, b T) bool
}

func (h *nodeHeap[T]) Len() int           { return len(h.arr) }
func (h *nodeHeap[T]) Less(i, j int) bool { return h.less(h.arr[i].node.Val, h.arr[j].node.Val) }
func (h *nodeHeap[T]) Swap(i, j int)      { h.arr[i], h.arr[j] = h.arr[j], h.arr[i] }
func (h *nodeHeap[T]) Push(x any)         { h.arr = append(h.arr, x.(*heapNode[T])) }
func (h *nodeHeap[T]) Pop() any {
    n := len(h.arr)
    x := h.arr[n-1]
    h.arr = h.arr[:n-1]
    return x
}

// 合并多个升序链表
func mergeKLists[T any](lists []*SinglyNode[T], less func(a, b T) bool) *SinglyNode[T] {
    h := &nodeHeap[T]{less: less}
    heap.Init(h)
    for _, node := range lists {
        if node != nil {
            heap.Push(h, &heapNode[T]{node: node})
        }
    }
    dummy := &SinglyNode[T]{}
    cur := dummy
    for h.Len() > 0 {
        minNode := heap.Pop(h).(*heapNode[T])
        cur.Next = minNode.node
        cur = cur.Next
        if minNode.node.Next != nil {
            heap.Push(h, &heapNode[T]{node: minNode.node.Next})
        }
    }
    return dummy.Next
}

用法举例：
lists := []*SinglyNode[int]{链表1头, 链表2头, ...}
merged := mergeKLists(lists, func(a, b int) bool { return a < b })
```