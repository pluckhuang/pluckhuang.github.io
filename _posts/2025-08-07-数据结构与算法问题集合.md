---
layout: post
title:  "数据结构与算法问题集合"
date:   2025-08-07 11:24:00 +0800
tags:
  - 后端
---

# 数据结构与算法问题集合

## 关于数组和链表的几个必知必会的代码实现

### 数组
1. 实现一个支持动态扩容的数组
```go
// 支持范型的动态数组（Go 1.18+）
type DynamicArray[T any] struct {
    data     []T
    capacity int
    size     int
}

func NewDynamicArray[T any](initCap int) *DynamicArray[T] {
    return &DynamicArray[T]{
        data:     make([]T, initCap),
        capacity: initCap,
        size:     0,
    }
}

func (a *DynamicArray[T]) Append(val T) {
    if a.size == a.capacity {
        newData := make([]T, a.capacity*2)
        copy(newData, a.data)
        a.data = newData
        a.capacity *= 2
    }
    a.data[a.size] = val
    a.size++
}

func (a *DynamicArray[T]) Get(idx int) T {
    if idx < 0 || idx >= a.size {
        panic("index out of range")
    }
    return a.data[idx]
}

func (a *DynamicArray[T]) Len() int {
    return a.size
}
```
2. 实现一个大小固定的有序数组，支持动态增删改操作
```go
// 固定大小有序数组，支持动态增删改（Go 1.18+）
type SortedArray[T any] struct {
    data     []T
    size     int
    capacity int
    less     func(a, b T) bool // 比较函数
}

func NewSortedArray[T any](cap int, less func(a, b T) bool) *SortedArray[T] {
    return &SortedArray[T]{
        data:     make([]T, cap),
        size:     0,
        capacity: cap,
        less:     less,
    }
}

// 插入元素，自动保持有序
func (a *SortedArray[T]) Insert(val T) bool {
    if a.size == a.capacity {
        return false // 超出容量
    }
    idx := 0
    for idx < a.size && a.less(a.data[idx], val) {
        idx++
    }
    // 插入并后移
    copy(a.data[idx+1:], a.data[idx:a.size])
    a.data[idx] = val
    a.size++
    return true
}

// 删除指定下标元素
func (a *SortedArray[T]) Delete(idx int) bool {
    if idx < 0 || idx >= a.size {
        return false
    }
    copy(a.data[idx:], a.data[idx+1:a.size])
    a.size--
    return true
}

// 修改指定下标元素并保持有序
func (a *SortedArray[T]) Update(idx int, val T) bool {
    if idx < 0 || idx >= a.size {
        return false
    }
    // 删除原元素
    old := a.data[idx]
    a.Delete(idx)
    // 插入新元素
    return a.Insert(val)
}

// 获取指定下标元素
func (a *SortedArray[T]) Get(idx int) T {
    if idx < 0 || idx >= a.size {
        panic("index out of range")
    }
    return a.data[idx]
}

func (a *SortedArray[T]) Len() int {
    return a.size
}
```

3. 实现两个有序数组合并为一个有序数组
```go
// 合并两个有序数组为一个有序数组（Go 1.18+）
func MergeSortedArrays[T any](a, b []T, less func(a, b T) bool) []T {
    i, j := 0, 0
    res := make([]T, 0, len(a)+len(b))
    for i < len(a) && j < len(b) {
        if less(a[i], b[j]) {
            res = append(res, a[i])
            i++
        } else {
            res = append(res, b[j])
            j++
        }
    }
    for i < len(a) {
        res = append(res, a[i])
        i++
    }
    for j < len(b) {
        res = append(res, b[j])
        j++
    }
    return res
}
```

### 链表
1. 实现单链表，支持增删操作
```go
type SinglyNode[T any] struct {
    Val  T
    Next *SinglyNode[T]
}

type SinglyList[T any] struct {
    Head *SinglyNode[T]
}

func (l *SinglyList[T]) Insert(val T) {
    node := &SinglyNode[T]{Val: val}
    node.Next = l.Head
    l.Head = node
}

func (l *SinglyList[T]) Delete(val T, equal func(a, b T) bool) bool {
    var prev *SinglyNode[T]
    cur := l.Head
    for cur != nil {
        if equal(cur.Val, val) {
            if prev == nil {
                l.Head = cur.Next
            } else {
                prev.Next = cur.Next
            }
            return true
        }
        prev = cur
        cur = cur.Next
    }
    return false
}
```

2. 实现循环链表，支持增删操作
```go
type CircularNode[T any] struct {
    Val  T
    Next *CircularNode[T]
}

type CircularList[T any] struct {
    Head *CircularNode[T]
}

func (l *CircularList[T]) Insert(val T) {
    node := &CircularNode[T]{Val: val}
    if l.Head == nil {
        node.Next = node
        l.Head = node
        return
    }
    cur := l.Head
    for cur.Next != l.Head {
        cur = cur.Next
    }
    cur.Next = node
    node.Next = l.Head
}

func (l *CircularList[T]) Delete(val T, equal func(a, b T) bool) bool {
    if l.Head == nil {
        return false
    }
    cur := l.Head
    var prev *CircularNode[T]
    for {
        if equal(cur.Val, val) {
            if prev == nil {
                // 删除头结点
                tail := l.Head
                for tail.Next != l.Head {
                    tail = tail.Next
                }
                if tail == l.Head {
                    l.Head = nil
                } else {
                    tail.Next = cur.Next
                    l.Head = cur.Next
                }
            } else {
                prev.Next = cur.Next
            }
            return true
        }
        prev = cur
        cur = cur.Next
        if cur == l.Head {
            break
        }
    }
    return false
}
```

3. 实现双向链表，支持增删操作
```go
type DoublyNode[T any] struct {
    Val  T
    Prev *DoublyNode[T]
    Next *DoublyNode[T]
}

type DoublyList[T any] struct {
    Head *DoublyNode[T]
    Tail *DoublyNode[T]
}

func (l *DoublyList[T]) InsertHead(val T) {
    node := &DoublyNode[T]{Val: val}
    node.Next = l.Head
    if l.Head != nil {
        l.Head.Prev = node
    }
    l.Head = node
    if l.Tail == nil {
        l.Tail = node
    }
}

func (l *DoublyList[T]) InsertTail(val T) {
    node := &DoublyNode[T]{Val: val}
    node.Prev = l.Tail
    if l.Tail != nil {
        l.Tail.Next = node
    }
    l.Tail = node
    if l.Head == nil {
        l.Head = node
    }
}

func (l *DoublyList[T]) Delete(val T, equal func(a, b T) bool) bool {
    cur := l.Head
    for cur != nil {
        if equal(cur.Val, val) {
            if cur.Prev != nil {
                cur.Prev.Next = cur.Next
            } else {
                l.Head = cur.Next
            }
            if cur.Next != nil {
                cur.Next.Prev = cur.Prev
            } else {
                l.Tail = cur.Prev
            }
            return true
        }
        cur = cur.Next
    }
    return false
}
```

4. 实现单链表反转
```go
type SinglyNode[T any] struct {
    Val  T
    Next *SinglyNode[T]
}

type SinglyList[T any] struct {
    Head *SinglyNode[T]
}

func (l *SinglyList[T]) Reverse() {
    var prev *SinglyNode[T]
    cur := l.Head
    for cur != nil {
        next := cur.Next
        cur.Next = prev
        prev = cur
        cur = next
    }
    l.Head = prev
}
```

5. 实现两个有序的链表合并为一个有序链表
```go
func MergeSortedLists[T any](l1, l2 *SinglyList[T], less func(a, b T) bool) *SinglyList[T] {
    dummy := &SinglyNode[T]{}
    cur := dummy
    p1, p2 := l1.Head, l2.Head
    for p1 != nil && p2 != nil {
        if less(p1.Val, p2.Val) {
            cur.Next = p1
            p1 = p1.Next
        } else {
            cur.Next = p2
            p2 = p2.Next
        }
        cur = cur.Next
    }
    if p1 != nil {
        cur.Next = p1
    }
    if p2 != nil {
        cur.Next = p2
    }
    return &SinglyList[T]{Head: dummy.Next}
}
```
6. 求单链表的中间结点（快慢指针法）
```go
func (l *SinglyList[T]) MiddleNode() *SinglyNode[T] {
    slow, fast := l.Head, l.Head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    return slow
}
```
7. Three Sum(求三数之和)
```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    res := [][]int{}
    n := len(nums)
    for i := 0; i < n-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue // 跳过重复
        }
        left, right := i+1, n-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                // 跳过重复
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return res
}
```
8. Majority Element(求众数)
```
func majorityElement(nums []int) int {
    res := make(map[int]int)
    for _, val := range nums {
        res[val]++
    }
    max, ret := 0, 0
    for k, v := range res {
        if v > max {
            ret = k
            max = v
        }
    }
    return ret
}
```
9. 判断链表中是否有环。
```go
func hasCycle[T any](head *SinglyNode[T]) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```
10. 给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。
```go
import (
    "container/heap"
)

// 堆节点结构
type heapNode[T any] struct {
    node *SinglyNode[T]
}

type nodeHeap[T any] struct {
    arr  []*heapNode[T]
    less func(a, b T) bool
}

func (h *nodeHeap[T]) Len() int           { return len(h.arr) }
func (h *nodeHeap[T]) Less(i, j int) bool { return h.less(h.arr[i].node.Val, h.arr[j].node.Val) }
func (h *nodeHeap[T]) Swap(i, j int)      { h.arr[i], h.arr[j] = h.arr[j], h.arr[i] }
func (h *nodeHeap[T]) Push(x any)         { h.arr = append(h.arr, x.(*heapNode[T])) }
func (h *nodeHeap[T]) Pop() any {
    n := len(h.arr)
    x := h.arr[n-1]
    h.arr = h.arr[:n-1]
    return x
}

// 合并多个升序链表
func mergeKLists[T any](lists []*SinglyNode[T], less func(a, b T) bool) *SinglyNode[T] {
    h := &nodeHeap[T]{less: less}
    heap.Init(h)
    for _, node := range lists {
        if node != nil {
            heap.Push(h, &heapNode[T]{node: node})
        }
    }
    dummy := &SinglyNode[T]{}
    cur := dummy
    for h.Len() > 0 {
        minNode := heap.Pop(h).(*heapNode[T])
        cur.Next = minNode.node
        cur = cur.Next
        if minNode.node.Next != nil {
            heap.Push(h, &heapNode[T]{node: minNode.node.Next})
        }
    }
    return dummy.Next
}

用法举例：
lists := []*SinglyNode[int]{链表1头, 链表2头, ...}
merged := mergeKLists(lists, func(a, b int) bool { return a < b })
```


## 关于栈、队列和递归的几个必知必会的代码实现

### 栈

1. 用数组实现一个顺序栈
```go
// 顺序栈（支持范型，Go 1.18+）
type Stack[T any] struct {
    data []T
    top  int
}

func NewStack[T any]() *Stack[T] {
    return &Stack[T]{data: make([]T, 0), top: -1}
}

func (s *Stack[T]) Push(val T) {
    s.data = append(s.data, val)
    s.top++
}

func (s *Stack[T]) Pop() (T, bool) {
    if s.top < 0 {
        var zero T
        return zero, false
    }
    val := s.data[s.top]
    s.data = s.data[:s.top]
    s.top--
    return val, true
}

func (s *Stack[T]) Peek() (T, bool) {
    if s.top < 0 {
        var zero T
        return zero, false
    }
    return s.data[s.top], true
}

func (s *Stack[T]) IsEmpty() bool {
    return s.top < 0
}

func (s *Stack[T]) Len() int {
    return s.top +

```

2. 用链表实现一个链式栈
```go
// 链式栈（支持范型，Go 1.18+）
type StackNode[T any] struct {
    Val  T
    Next *StackNode[T]
}

type LinkedStack[T any] struct {
    top *StackNode[T]
    size int
}

func NewLinkedStack[T any]() *LinkedStack[T] {
    return &LinkedStack[T]{top: nil, size: 0}
}

func (s *LinkedStack[T]) Push(val T) {
    node := &StackNode[T]{Val: val, Next: s.top}
    s.top = node
    s.size++
}

func (s *LinkedStack[T]) Pop() (T, bool) {
    if s.top == nil {
        var zero T
        return zero, false
    }
    val := s.top.Val
    s.top = s.top.Next
    s.size--
    return val, true
}

func (s *LinkedStack[T]) Peek() (T, bool) {
    if s.top == nil {
        var zero T
        return zero, false
    }
    return s.top.Val, true
}

func (s *LinkedStack[T]) IsEmpty() bool {
    return s.top == nil
}

func (s *LinkedStack[T]) Len() int {
    return s.size
}
```

3. 编程模拟实现一个浏览器的前进、后退功能
```go
// 浏览器前进/后退功能模拟（Go 1.18+）
type Browser[T any] struct {
    backStack    *LinkedStack[T] // 后退栈
    forwardStack *LinkedStack[T] // 前进栈
    current      T
    hasCurrent   bool
}

func NewBrowser[T any]() *Browser[T] {
    return &Browser[T]{
        backStack:    NewLinkedStack[T](),
        forwardStack: NewLinkedStack[T](),
        hasCurrent:   false,
    }
}

// 打开新页面
func (b *Browser[T]) Open(page T) {
    if b.hasCurrent {
        b.backStack.Push(b.current)
    }
    b.current = page
    b.hasCurrent = true
    b.forwardStack = NewLinkedStack[T]() // 清空前进栈
}

// 后退
func (b *Browser[T]) Back() bool {
    if b.backStack.IsEmpty() {
        return false
    }
    b.forwardStack.Push(b.current)
    b.current, _ = b.backStack.Pop()
    return true
}

// 前进
func (b *Browser[T]) Forward() bool {
    if b.forwardStack.IsEmpty() {
        return false
    }
    b.backStack.Push(b.current)
    b.current, _ = b.forwardStack.Pop()
    return true
}

// 获取当前页面
func (b *Browser[T]) Current() (T, bool) {
    return b.current, b.hasCurrent
}
```

### 队列
1. 用数组实现一个顺序队列(循环队列)
```go
// 顺序队列（支持范型，Go 1.18+）
type Queue[T any] struct {
    data  []T
    front int
    rear  int
    size  int
}

func NewQueue[T any](cap int) *Queue[T] {
    return &Queue[T]{
        data:  make([]T, cap),
        front: 0,
        rear:  0,
        size:  0,
    }
}

func (q *Queue[T]) Enqueue(val T) bool {
    if q.size == len(q.data) {
        return false // 队列满
    }
    q.data[q.rear] = val
    q.rear = (q.rear + 1) % len(q.data)
    q.size++
    return true
}

func (q *Queue[T]) Dequeue() (T, bool) {
    if q.size == 0 {
        var zero T
        return zero, false
    }
    val := q.data[q.front]
    q.front = (q.front + 1) % len(q.data)
    q.size--
    return val, true
}

func (q *Queue[T]) IsEmpty() bool {
    return q.size == 0
}

func (q *Queue[T]) IsFull() bool {
    return q.size == len(q.data)
}

func (q *Queue[T]) Len() int {
    return
```

2. 用链表实现一个链式队列
```go
// 链式队列（支持范型，Go 1.18+）
type QueueNode[T any] struct {
    Val  T
    Next *QueueNode[T]
}

type LinkedQueue[T any] struct {
    head *QueueNode[T]
    tail *QueueNode[T]
    size int
}

func NewLinkedQueue[T any]() *LinkedQueue[T] {
    return &LinkedQueue[T]{head: nil, tail: nil, size: 0}
}

func (q *LinkedQueue[T]) Enqueue(val T) {
    node := &QueueNode[T]{Val: val}
    if q.tail != nil {
        q.tail.Next = node
    } else {
        q.head = node
    }
    q.tail = node
    q.size++
}

func (q *LinkedQueue[T]) Dequeue() (T, bool) {
    if q.head == nil {
        var zero T
        return zero, false
    }
    val := q.head.Val
    q.head = q.head.Next
    if q.head == nil {
        q.tail = nil
    }
    q.size--
    return val, true
}

func (q *LinkedQueue[T]) IsEmpty() bool {
    return q.size == 0
}

func (q *LinkedQueue[T]) Len() int {
    return q.size
}
```

### 递归

1. 编程实现斐波那契数列求值 f(n)=f(n-1)+f(n-2)
```go
func fib(n int) int {
    if n <= 1 {
        return n
    }
    return fib(n-1) + fib(n-2)
}
```
2. 递归实现阶乘 n!
```go
func factorial(n int) int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n-1)
}
```
3. Valid Parentheses(有效的括号)
```go
// 有效的括号判断（Go 1.18+）
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{')': '(', ']': '[', '}': '{'}
    for _, ch := range s {
        switch ch {
        case '(', '[', '{':
            stack = append(stack, ch)
        case ')', ']', '}':
            if len(stack) == 0 || stack[len(stack)-1] != pairs[ch] {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```
4. 逆波兰表达式求值
```go
// 逆波兰表达式（后缀表达式）求值
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+", "-", "*", "/":
            b := stack[len(stack)-1]
            a := stack[len(stack)-2]
            stack = stack[:len(stack)-2]
            var res int
            switch token {
            case "+":
                res = a + b
            case "-":
                res = a - b
            case "*":
                res = a * b
            case "/":
                res = a / b
            }
            stack = append(stack, res)
        default:
            num, _ := strconv.Atoi(token)
            stack = append(stack, num)
        }
    }
    return stack[0]
}
```

5. 设计循环双端队列
```go
// 循环双端队列（Go 1.18+）
type CircularDeque[T any] struct {
    data  []T
    front int
    rear  int
    size  int
}

func NewCircularDeque[T any](cap int) *CircularDeque[T] {
    return &CircularDeque[T]{
        data:  make([]T, cap),
        front: 0,
        rear:  0,
        size:  0,
    }
}

// 队头插入
func (q *CircularDeque[T]) PushFront(val T) bool {
    if q.size == len(q.data) {
        return false // 满
    }
    q.front = (q.front - 1 + len(q.data)) % len(q.data)
    q.data[q.front] = val
    q.size++
    return true
}

// 队尾插入
func (q *CircularDeque[T]) PushBack(val T) bool {
    if q.size == len(q.data) {
        return false // 满
    }
    q.data[q.rear] = val
    q.rear = (q.rear + 1) % len(q.data)
    q.size++
    return true
}

// 队头弹出
func (q *CircularDeque[T]) PopFront() (T, bool) {
    if q.size == 0 {
        var zero T
        return zero, false
    }
    val := q.data[q.front]
    q.front = (q.front + 1) % len(q.data)
    q.size--
    return val, true
}

// 队尾弹出
func (q *CircularDeque[T]) PopBack() (T, bool) {
    if q.size == 0 {
        var zero T
        return zero, false
    }
    q.rear = (q.rear - 1 + len(q.data)) % len(q.data)
    val := q.data[q.rear]
    q.size--
    return val, true
}

func (q *CircularDeque[T]) IsEmpty() bool {
    return q.size == 0
}

func (q *CircularDeque[T]) IsFull() bool {
    return q.size == len(q.data)
}

func (q *CircularDeque[T]) Len() int {
```

6. 爬楼梯(假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？)
```go
// 爬楼梯问题，动态规划解法
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    a, b := 1, 2
    for i := 3; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

### 关于排序和二分查找的几个必知必会的代码实现
#### 排序
1. 实现归并排序
```go
// 归并排序（Go 1.18+，支持范型）
func mergeSort[T any](arr []T, less func(a, b T) bool) []T {
    if len(arr) <= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid], less)
    right := mergeSort(arr[mid:], less)
    return merge(left, right, less)
}

func merge[T any](a, b []T, less func(a, b T) bool) []T {
    res := make([]T, 0, len(a)+len(b))
    i, j := 0, 0
    for i < len(a) && j < len(b) {
        if less(a[i], b[j]) {
            res = append(res, a[i])
            i++
        } else {
            res = append(res, b[j])
            j++
        }
    }
    res = append(res, a[i:]...)
    res = append(res, b[j:]...)
    return res
}

nums := []int{5, 2, 4, 7, 1, 3, 6}
sorted := mergeSort(nums, func(a, b int) bool { return a < b })
```
2. 快速排序
```go
// 快速排序（Go 1.18+，支持范型）
func quickSort[T any](arr []T, less func(a, b T) bool) {
    var sort func(left, right int)
    sort = func(left, right int) {
        if left >= right {
            return
        }
        pivot := arr[left]
        i, j := left, right
        for i < j {
            for i < j && !less(arr[j], pivot) {
                j--
            }
            if i < j {
                arr[i] = arr[j]
                i++
            }
            for i < j && less(arr[i], pivot) {
                i++
            }
            if i < j {
                arr[j] = arr[i]
                j--
            }
        }
        arr[i] = pivot
        sort(left, i-1)
        sort(i+1, right)
    }
    sort(0, len(arr)-1)
}

nums := []int{5, 2, 4, 7, 1, 3, 6}
quickSort(nums, func(a, b int) bool { return a < b })
```
3. 插入排序
```go
// 插入排序（Go 1.18+，支持范型）
func insertionSort[T any](arr []T, less func(a, b T) bool) {
    n := len(arr)
    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && less(key, arr[j]) {
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
}

nums := []int{5, 2, 4, 7, 1, 3, 6}
insertionSort(nums, func(a, b int) bool { return a < b })
```

4. 冒泡排序
```go
// 冒泡排序（Go 1.18+，支持范型）
func bubbleSort[T any](arr []T, less func(a, b T) bool) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-1-i; j++ {
            if less(arr[j+1], arr[j]) {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}

// 用法示例
nums := []int{5, 2, 4, 7, 1, 3, 6}
bubbleSort(nums, func(a, b int) bool { return a <
```

5. 选择排序
```go
// 选择排序（Go 1.18+，支持范型）
func selectionSort[T any](arr []T, less func(a, b T) bool) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        minIdx := i
        for j := i + 1; j < n; j++ {
            if less(arr[j], arr[minIdx]) {
                minIdx = j
            }
        }
        if minIdx != i {
            arr[i], arr[minIdx] = arr[minIdx], arr[i]
        }
    }
}

// 用法示例
nums := []int{5, 2, 4, 7, 1, 3, 6}
selectionSort(nums, func(a, b int) bool { return a < b
```
6.  O(􏰀n) 时间复杂度内找到一组数据的第 K 大元素
```go
// 快速选择算法，O(n) 平均时间复杂度，找第 K 大元素（Go 1.18+）
func findKthLargest(nums []int, k int) int {
    n := len(nums)
    target := n - k // 转为第 (n-k) 小
    var quickSelect func(left, right int) int
    quickSelect = func(left, right int) int {
        pivot := nums[left]
        i, j := left, right
        for i < j {
            for i < j && nums[j] >= pivot {
                j--
            }
            if i < j {
                nums[i] = nums[j]
                i++
            }
            for i < j && nums[i] <= pivot {
                i++
            }
            if i < j {
                nums[j] = nums[i]
                j--
            }
        }
        nums[i] = pivot
        if i == target {
            return nums[i]
        } else if i < target {
            return quickSelect(i+1, right)
        } else {
            return quickSelect(left, i-1)
        }
    }
    return quickSelect(0, n-1)
}
```
#### 二分查找


1. 实现一个有序数组的二分查找算法
```go
// 二分查找（Go 1.18+，支持范型）
func binarySearch[T any](arr []T, target T, less func(a, b T) bool, equal func(a, b T) bool) int {
    left, right := 0, len(arr)-1
    for left <= right {
        mid := left + (right-left)/2
        if equal(arr[mid], target) {
            return mid
        } else if less(arr[mid], target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1 // 未找到
}

// 用法示例
nums := []int{1, 2, 3, 4, 5, 6, 7}
idx := binarySearch(nums, 4, func(a, b int) bool { return a < b }, func(a, b int) bool { return a == b })
// idx == 3
```
2. 实现模糊二分查找算法(比如大于等于给定值的第一个元素)
```go
// 模糊二分查找：返回大于等于 target 的第一个元素下标（Go 1.18+，支持范型）
func lowerBound[T any](arr []T, target T, less func(a, b T) bool) int {
    left, right := 0, len(arr)
    for left < right {
        mid := left + (right-left)/2
        if less(arr[mid], target) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    // 如果 left == len(arr)，说明没有大于等于 target 的元素
    return left
}

// 用法示例
nums := []int{1, 2, 4, 4, 5, 7}
idx := lowerBound(nums, 4, func(a, b int) bool { return a < b }) //
```

3. x 的平方根
```go
// 用二分查找实现 x 的平方根（返回整数部分）
func mySqrt(x int) int {
    if x < 2 {
        return x
    }
    left, right := 1, x
    for left <= right {
        mid := left + (right-left)/2
        if mid*mid == x {
            return mid
        } else if mid*mid < x {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return right // 返回不超过 x 的最大整数
}

// 用法示例
// mySqrt(8) 返回
```